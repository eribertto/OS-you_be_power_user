All right, we've learned a bunch of individual, very powerful tools. These are the most important day-to-day commands that you'll need to work in PowerShell. Now, we're going to learn how to combine these tools to make them even more powerful. Let's run the following command in our desktop directory. Then we'll break it down piece by piece. Scan cd into my desktop directory. Okay, I go woof > dog.txt. Will do an LS to check our desktop, and we'll now see a file called dog.txt. Inside that file, we should see the word, woof. Oh, there it is. What's happening here? Let's take a closer look, echo woof. In PowerShell, the echo is actually an alias for Write-Output. That gives us a clue to what's happening. We know the echo command prints out our keyboard input to the screen. But how does this work? Every Windows process and every PowerShell command can take input and can produce output. To do this, we use something known as I/O streams or input output streams. Each process in Windows has three different streams: standard in, standard out, and standard error. It's helpful to think of these streams like actual water streams in a river. You provide input to a process by adding things to the standard in stream, which flows into the process. When the process creates output, it adds data to the standard out stream, which flows out of the process. At the CLI, the input that you provide through the keyboard goes to the standard in stream of the process that you're interacting with. This happens whether that's PowerShell, a text editor, or anything else. The process then communicates back to you by putting data into the Standard out stream, which the CLI writes out on the screen that you're looking at. Now, what if instead of seeing the output of the command on the screen, we wanted to save it to a file? The greater than symbol is something we call a redirector operator that lets us change where we want our standard output to go. Instead of sending standard out to the screen, we can send a standard out to a file. If the file exists, it'll overwrite it for us. Otherwise, it'll make a new file. If we don't want to overwrite an existing file, there's another redirector operator we can use to append information, greater than, greater than. So let's see that in action, echo woof >> dog.txt. Now, if I look at my dog.txt file again, we can see that woof was added again. But, what if we wanted to send the output of one command to the input of another command? For this, we're going to use the pipe operator. First, let's take a look at what's in this file. cat words.txt. Look at that, it's a list of words. Now, what if we want to just list the words that contain the string st? We can do what we've done before and just use select-string or SLS on the file directly. This time, let's use the pipeline to pass the output of cat to the input of select-string. So cat words.txt | select-string st. And now, we can see a list of words with the string st. To tie things together, we can use output redirection to put our new list into a file. So now, greater than, and then a new file called st words.txt. Now, if I cat st words.txt, yup, there it is. That's just a very basic example of how you can take several simple tools and combine them together to do complex tasks. Okay, now we're going to learn about the last I/O redirector, standard error. Remember when we tried to remove a restricted system file earlier and we got an error that said permission denied? Let's review that once more. This time, I'm going to remove another protected file, rm secure_file. We see errors like we're supposed to. But what if we didn't want to see these errors? Turns out, we can just redirect the output of error messages in a different output stream called standard error. The redirection operator can be used to redirect any of the output streams, but we have to tell which stream to redirect. So, let's type, rm secure_file 2> errors.txt. If I look at errors.txt, I can see the error message that we just got. So, what does the two mean? All of the output streams are numbered. One is for standard out, which is the output that you normally see, and two is for standard error or the error messages. Heads up, PowerShell actually has a few more streams that we aren't going to use in this lesson. But they can be redirected in the same way. You can read more about them in the supplemental reading right after this video. So when we use two greater than, we're telling PowerShell to redirect the standard error stream to the file instead of standard out. What if we don't care about the error messages, but we don't want to put them in a file? Using our newly learned redirector operators, we can actually filter out these error messages. In PowerShell, we can do this by redirecting standard error to $null. What's $null? Well, it's nothing. No, really. It's a special variable that contains the definition of nothing. You can think of it as a black hole for the purposes of redirection. So let's redirect the error messages this time to $null, rm secure_file 2> $null. Now, our output is filtered from error messages. There's still much more to learn if you're interested. Try Get-Help about_redirection in PowerShell to see more detail. It may take a little time to get the hang of using redirector operators. Don't worry, that's totally normal. Once you do start to get used to them, you'll notice your command full skills level up and your job becomes a little easier. Now, let's take a look at output redirection in Linux.
